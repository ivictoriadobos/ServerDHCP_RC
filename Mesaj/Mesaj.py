import binascii

from Mesaj import Optiuni
from time import time


class Mesaj:
    def __init__(self, _mesajDHCP):
        self.mesajDHCP = _mesajDHCP
        self.op = ""
        """
        Tipul mesajului : # 1  client -> server, 2  server -> client (1 octet)
        """

        self.htype = 1
        """
        Hardware type (by default 1) (1 octet)
        """

        self.hlen = 6
        """
        Hardware Address Length: Specifies how long hardware addresses are in this message
        (pentru ethernet (htype = 1) e 6) ( 1 octet )
        """

        self.hops = 0
        """
        Set to 0 by a client before transmitting a request and used by relay agents to control the forwarding of BOOTP 
        and/or DHCP messages  ( 1 octet )
         """

        self.xid = ""
        """Transaction Identifier : field generated by the client, to allow it to match up the request with replies 
        received from DHCP servers. ( 4 octeti )"""

        self.secs = ""
        """For DHCP, it is defined as the number of seconds elapsed since a client began an attempt to acquire or renew a 
        lease. This may be used by a busy DHCP server to prioritize replies when multiple client requests are outstanding 
         (2 octeti) """

        self.flags = ""
        """B subfield ( 1 octet ) : a client that doesn't know its own IP address at the time it sends its request sets 
        this flag to 1. This serves as an immediate indicator to the DHCP server or relay agent that receives the request 
        that it should send its reply back by broadcast. Reserved subfield (1 octet) : set to zero and not used (2 
        octeti) """

        self.ciaddr = ""
        """The client puts its own current IP address in this field if and only if it has a valid IP address while in the 
        BOUND, RENEWING or REBINDING states; otherwise, it sets the field to 0. The client can only use this field when 
        its address is actually valid and usable, not during the process of acquiring an address. Specifically, 
        the client does not use this field to request a particular IP address in a lease; it uses the Requested IP 
        Address DHCP option. (4 octeti) """

        self.yiaddr = ""
        """“Your” IP Address: The IP address that the server is assigning to the client.
        (4 octeti)"""

        self.siaddr = ""
        """In DHCP, it is the address of the server that the client should use for the next step in the bootstrap 
        process, which may or may not be the server sending this reply. 
    The sending server always includes its own IP address in the Server Identifier DHCP option.
        (4 octeti)"""

        self.giaddr = ""
        """This field is used just as it is in BOOTP, to route BOOTP messages when BOOTP relay agents are involved to 
        facilitate the communication of BOOTP requests and replies between a client and a server on different subnets or 
        networks. (4 octeti) """

        self.chaddr = ""
        """Client Hardware Address: The hardware (layer two) address of the client, which is used for identification and 
        communication. (16 octeti) """

        self.sname = ""
        """Server Name: The server sending a DHCPOFFER or DHCPACK message may optionally put its name in this field. This 
        can be a simple text “nickname” or a fully-qualified DNS domain name (such as “myserver.organization.org”). (64 
        octeti ) """

        self.file = ""
        """
        Optionally used by a client to request a particular type of boot file in a DHCPDISCOVER message. Used by a server in a
         DHCPOFFER to fully specify a boot file directory path and filename. (128 octeti)"""
        self.magic_cookie = "63.82.53.63"
        """
        Magic cookie (4 octeti)"""

        self.optiuni = {}


    def parseazaMesaj(self):
            startIndex = 0
            endIndex = 0
            # valorile sunt hardcodate deoarece nu ne intereseaza sa oferim functionalitate variabila unor lungimi definite
            # OP
            endIndex += 2
            self.op = self.mesajDHCP[startIndex:endIndex]

            # HTYPE
            startIndex = endIndex
            endIndex += 2
            self.htype = self.mesajDHCP[startIndex:endIndex]


            # HLEN
            startIndex = endIndex
            endIndex += 2
            self.hlen = self.mesajDHCP[startIndex:endIndex]

            # HOPS
            startIndex = endIndex
            endIndex += 2
            self.hops = self.mesajDHCP[startIndex:endIndex]

            # XID
            startIndex = endIndex
            endIndex += 8
            self.xid = self.mesajDHCP[startIndex:endIndex]

            # SECS
            startIndex = endIndex
            endIndex += 4
            self.secs = self.mesajDHCP[startIndex:endIndex]

            # FLAGS
            startIndex = endIndex
            endIndex += 4
            self.flags = self.mesajDHCP[startIndex:endIndex]

            # CIADDR
            startIndex = endIndex
            endIndex += 8
            self.ciaddr = self.mesajDHCP[startIndex:endIndex]
            self.ciaddr = self.parseazaAdresaIP(self.ciaddr)

            if not self.ciaddr:
                return -1

            # YIADDR
            startIndex = endIndex
            endIndex += 8
            self.yiaddr = self.mesajDHCP[startIndex:endIndex]
            self.yiaddr = self.parseazaAdresaIP(self.yiaddr)
            if not self.yiaddr:
                print("\nHere in yiaddr")
                return -1

            # SIADDR
            startIndex = endIndex
            endIndex += 8
            self.siaddr = self.mesajDHCP[startIndex:endIndex]
            self.siaddr = self.parseazaAdresaIP(self.siaddr)
            if not self.siaddr :
                print("\nHere in siaddr")
                return -1

            # GIADDR
            startIndex = endIndex
            endIndex += 8
            self.giaddr = self.mesajDHCP[startIndex:endIndex]
            self.giaddr = self.parseazaAdresaIP(self.giaddr)
            if not self.giaddr :
                print("\nHere in giaddr")
                return -1

            # CHADDR
            startIndex = endIndex
            endIndex += 32
            self.chaddr = self.mesajDHCP[startIndex:endIndex]
            self.chaddr = self.parseazaMAC(self.chaddr)
            if not self.chaddr:
                print("\nHere in chaddr")
                return -1

            # SNAME
            startIndex = endIndex
            endIndex += 128
            self.sname = self.mesajDHCP[startIndex:endIndex]
            self.sname = self.parseazaString(self.sname)
            if self.sname is False:
                print("\nHere in sname")
                return -1


            # FILE
            startIndex = endIndex
            endIndex += 256
            self.file = self.mesajDHCP[startIndex:endIndex]
            self.file = self.parseazaString(self.file)
            if  self.file is False:
                print("\nMesaj: \t file : " + str(self.file))
                return -1

            # MAGIC COOKIE
            startIndex = endIndex
            endIndex += 8
            self.magic_cookie = self.mesajDHCP[startIndex:endIndex]

            # OPTIONS
            startIndex = endIndex
            endIndex = len(self.mesajDHCP)


            _optiuni = Optiuni.Optiuni(self.mesajDHCP[startIndex:endIndex])

            _optiuni.parseazaOptiuni()
            _optiuni.decodeazaOptiuni()
            self.optiuni = _optiuni.getOptiuni()

            for option in self.optiuni:
                if not self.optiuni[option] : #daca vreo optiune e eronata/ nu s-a parsat bine
                    return -1
            return 0

    def parseazaAdresaIP(self, adresa):

        if len(adresa) != 8:
            return False
        else:
            _adresa = str(int(adresa[0:2], base=16)) + "." + str(int(adresa[2:4], base=16)) + "." + str(int(adresa[4:6], base=16)) + "." + str(int(adresa[6:8], base=16))

        return _adresa

    def parseazaMAC(self, adresa):
        if len(adresa) != 32: #in mesaj sunt 16 octeti pentru adresa MAC, desi ea e compusa doar din 6..
            return False
        else:
            # newAddress = "%s:%s:%s:%s:%:%s" %
            # (address[0:2], address[2:4], address[4:6],address[6:8],address[8:10],address[10:12])
            mac = adresa[0:2] + ":" + adresa[2:4] + ":" + adresa[4:6] + ":" + adresa[6:8] + ":" + adresa[8:10] + ":" + adresa[10:12]
            return mac

    def parseazaString(self, _string):

        if len(_string) == 0:
            print("\nMesaj : string length = 0! ")
            return False
        else:
            string = ""
            startIndex = 0 # mergem din octet in octet (deci verificam cate 2 litere/cifre)
            endIndex = 2
            while _string[startIndex:endIndex] != "00" and endIndex <= len(_string):
                string += chr(int(_string[startIndex:endIndex], base=16))
                startIndex = endIndex
                endIndex += 2
            return string

    def getTypeOfMessage(self):
        return self.optiuni[53]

    def setTypeOfMessage(self, string):
        self.optiuni[53] = string

    def setYiaddr(self, string):
        self.yiaddr = string


    def messageToBytes(self):
        mesaj = str(self.op) + str(self.htype) + str(self.hlen) + str(self.hops) + self.xid + self.secs + self.flags

        mesaj += self.ipToBytes(self.ciaddr) + self.ipToBytes(self.yiaddr) + self.ipToBytes(self.siaddr) + self.ipToBytes(self.giaddr)

        mesaj += self.macToBytes(self.chaddr)

        mesaj += self.stringToBytes(self.sname) + '00' * (64 - len(self.sname))
        mesaj += self.stringToBytes(self.file) + (128 - len(self.file)) * '00'

        mesaj += self.magic_cookie

        for option in self.optiuni:
            if option == 1:
                length = len(self.ipToBytes(self.optiuni[option])) / 2 #impartim la 2 fiindca 2 litere in hexa = 1 octet, iar noi dam lungimea in octeti
                mesaj += "0" + str(option) + "0" + str(int(length)) + self.ipToBytes(self.optiuni[option])

            if option == 3:
                aux = self.optiuni[option].split(" ")
                length = 0
                buff = ""
                for i in range(0, len(aux)):
                    buff += self.ipToBytes(aux[i])
                    length += len(self.ipToBytes(aux[i]))
                mesaj += "0" + str(option) + "0" + str(int(length / 2)) + buff #presupunem si noi ca nu avem mai mult de 2 adrese date aici :)))

            if option == 6:
                aux = self.optiuni[option].split(" ")
                length = 0
                buff = ""
                for i in range(0, len(aux)):
                    buff += self.ipToBytes(aux[i])
                    length += len(self.ipToBytes(aux[i]))
                mesaj += "0" + str(option) + "0" + str(int(length / 2)) + buff

            if option == 15:
                length = len(self.optiuni[option])
                code = "0" + str(hex(option))[2:]
                if length < 10:
                    mesaj += code + "0" + str(length) + self.stringToBytes(self.optiuni[option])
                else:
                    mesaj += code + str(length) + self.stringToBytes(self.optiuni[option])

            if option == 28:
                length = len(self.ipToBytes(self.optiuni[option])) / 2
                mesaj += str(hex(option))[2:] + "0" + str(int(length)) + self.ipToBytes(self.optiuni[option])

            if option == 51:
                time = str(hex(int(self.optiuni[option])))[2:]
                dim = len(time)
                while dim < 8:
                    time = "0" + time
                    dim += 1
                mesaj += str(hex(option))[2:] + "04" + time

            # DHCP Message Type
            if option == 53:
                DHCPMessageTypeEncode = {
                    "DHCPDISCOVER": 1,
                    "DHCPOFFER": 2,
                    "DHCPREQUEST": 3,
                    "DHCPDECLINE": 4,
                    "DHCPACK": 5,
                    "DHCPNAK": 6,
                    "DHCPRELEASE": 7,
                    "DHCPINFORM": 8
                }
                print(self.optiuni[53])
                print(str(DHCPMessageTypeEncode[self.optiuni[53]]))
                mesaj += str(hex(option))[2:] + "01" + "0" + str(DHCPMessageTypeEncode[self.optiuni[53]])

            # Server Identifier
            if option == 54:
                length = len(self.ipToBytes(self.optiuni[option])) / 2
                mesaj += str(hex(option))[2:] + "0" + str(int(length)) + self.ipToBytes(
                    self.optiuni[option])

        mesaj += "ff"
        mesaj = bytes(mesaj.upper(), encoding="utf-8")
        return mesaj


    def ipToBytes(self, address):
        addr = address.split(".")
        if len(addr) == 4:
            ipBytes = ""
            for i in range(4):
                # taiem primele 2 caractere pentu ca functia hex returneaza un numar de forma 0x348534.
                data = hex(int(addr[i], base=10))[2:]
                if int(data, base=16) < 0x10: # 9 in hexa ar fi 0x9, noi vrem 0x09
                    data = "0" + data
                ipBytes += data
            return ipBytes
        else:
            return ''



    def macToBytes(self, address):
        mac = address.split(":")
        if len(mac) == 6:
            macBytes = ""
            for i in range(6):
                macBytes += mac[i]  #adresa mac e deja in hexa, doar ca e desfacuta in cate 6 octeti
            # Adaugam zerouri
            while len(macBytes) != 32:
                macBytes += "0"
            return macBytes
        else:
            return ''

    def stringToBytes(self, string):
        if string and len(string) < 128:
            stringBytes = bytearray(string, encoding="utf-8")
            stringBytes = binascii.hexlify(stringBytes)
            stringBytes = stringBytes.decode("utf-8")
            return stringBytes
        else:
            return ''

    def printeazaMesaj(self):
        print("\n~~~START OF MSG")
        print("\nTipul mesajului : " + self.optiuni[53] )
        print("\n\tOP:" + str(self.op))
        print("\n\tXID:" + self.xid)
        print("\n\tCIADDR:" + self.ciaddr)
        print("\n\tYIADDR:" + self.yiaddr)
        print("\n\tCHADDR" + self.chaddr)
        print("\n\tMAGIC:" + self.magic_cookie)
        print("\n\n\tOptiunile mesajului:")
        for optiunek, optiunev in self.optiuni.items():
            if str(type(optiunev)) in ["<class 'str'>", "<class 'int'>"]:
                print("\n\t\tCod optiune: " + str(optiunek) + ", valoare optiune: " + str(optiunev))
            else:
                print("\n\t\tCod optiune: " + str(optiunek) + ", valoare optiune: ", end='')
                for optiune in optiunev:
                    print(optiune, end=' ')

        print("\n~~~END OF MSG")