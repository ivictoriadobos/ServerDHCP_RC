import socket

#orice nu e comentat a se intelege ca sunt niste setari care asa se cer facute
dhcp_discover = {
    'op': b'01', #message type = 1 => DHCPDISCOVER
    'htype': b'01',
    'hlen': b'06',
    'hops': b'00',
    'xid': b'37a548a1', #transaction identifier generated by client : punem si noi un nr acolo
    'secs': b'0000',
    'flags': b'8000',
    'ciaddr': b'00000000',
    'yiaddr': b'00000000',
    'siaddr': b'00000000',
    'giaddr': b'00000000',
    'chaddr': b'8125f59fefac00000000000000000000',
    'sname': b'00' * 64,
    'file': b'00' * 128,
    'magic cookie': b'63825363',
    'options': b'350101' +  #option 53 : message type  = discover ; code = 35 (53 in decimal), length = 01 = 1 octet (adica 2 litere in hexa) , 01 e valoarea (dhcp discover)
               b'3d078125f59fefac54' +  #optiunea 61 : Client Identifier : mostly the chaddr + alte numere;
               b'3204c0a80004' +  # option 50 : se cere o adresa ip specifica
               b'0c09466c6f72696e2d5043' + #The laptop's name, option 12
               b'370c010f0306021c1f2179f92b' +  #optiunea 55 parameter request = lista de coduri cu optiunile cerute de client, aici spre exemplu e 1,15,3,6,2,28....
               b'ff'  #endmark
}

#functie ajutatoare pentru debug
def dict_to_bytes(message):
    rez = b''
    for key, val in message.items():
        rez += message[key]
    return rez

client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
client_socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
client_socket.bind(('0.0.0.0', 68))
print("\nC:About to send a discover message")
client_socket.sendto(dict_to_bytes(dhcp_discover), ('255.255.255.255', 67))
print("\nDHCPDISCOVER sent")

data = client_socket.recvfrom(300)
print("C: Received this thing : " + data[0].decode('utf-8'))

print("\nC:About to send a request message")
client_socket.sendto(b'Request msg broooo', ('255.255.255.255', 67))
print("\nDHCPREQUEST sent")






import math

from AddressStuff.IPAddress import *

class AddressPool:

    def __init__(self, _ip, _mask):

        self.adreseIP = [] #aici vom stoca adresele ip generate in urma adresei de retea si masca

        self.adresa_retea = _ip

        self.adresa_difuzie = ""

        self.masca = []


        for val in _mask.split('.'):
            self.masca.append(int(val))

        total_ips = 0
        nr_zeroes =0
        for x in range(0,4): #0 1 2 3
            if self.masca[x] == 255:
                continue
            else:
                nr_zeroes_cur = 255-self.masca[x] + 1 # de ex 255-252 = 3 + 1 = 4 ; sqrt(4) = 2 = numarul de zerouri din masca din valoare curenta : 11111100 = 252
                nr_zeroes += math.log2(nr_zeroes_cur)

        total_ips = 2**nr_zeroes   # as formula says : nrOfIPs = 2^x-2, where x is the no of 0's in the subnet mask;
        #this does include the first(gateway) and the last (broadcast) addr

        print("\nNr de ipuri pt masca " + _mask + "  = " +str(total_ips))
        print("\nAdresa de retea:" + self.adresa_retea)
        #Build the address pool
        ip = []
        for x in _ip.split('.'):
            ip.append(int(x))
        for i in range (1,int(total_ips)):
            ip[3] += 1
            if ip[3] > 255:
                ip[3] = 0
                ip[2] += 1
                if ip[2] > 255:
                    ip[2] = 0
                    ip[1] += 1
                    if ip[1] > 255:
                        ip[1] = 0
                        ip[0] += 1
            self.adreseIP.append(IPAddress(str(ip[0]) + '.' + str(ip[1]) + '.' + str(ip[2]) + '.' + str(ip[3])))
            print("\n\tappending this ip addr to the pool : " + str(ip[0]) + '.' + str(ip[1]) + '.' + str(ip[2]) + '.' + str(ip[3]))

            self.adresa_difuzie =  str(ip[0]) + '.' + str(ip[1]) + '.' + str(ip[2]) + '.' + str(ip[3])
            self.server_identifier =  str(ip[0]) + '.' + str(ip[1]) + '.' + str(ip[2]) + '.' + str(ip[3] -1)
            print("\nserver_identifier " + self.server_identifier)


            self.adreseIP.remove(IPAddress( str(ip[0]) + '.' + str(ip[1]) + '.' + str(ip[2]) + '.' + str(ip[3] - 1))) #eliminam adresa pt server_identifier
            self.adreseIP.remove(IPAddress( str(ip[0]) + '.' + str(ip[1]) + '.' + str(ip[2]) + '.' + str(ip[3] ))) #eliminam adresa de difuzie


    def getFreeAddress(self, _mac):
        ip = None
        for _ip in self.adreseIP:
            if _ip.free == True and _ip.keep == False:
                _ip.setMac(_mac)
                _ip.set_IP_unavailable()
                _ip.keep_IP_address()
                ip = _ip
        return ip


    def getIPAddress(self, option50, _mac ):
        """
        Functie ce intoarce un obiect IPAddress si care tine cont de urmatoarele:
        1)Intai verificam daca masina care cere o adresa IP este printre cele care au asignat static o adresa IP si aceea le revine doar lor mereu
        2)Verificam preferinta masinii analizand optiunea 50, daca ea exista
        3)Daca niciuna de mai sus nu intoarce un IP masinii, inseamna ca putem aloca un IP oarecare din adress pool ul nostru.
        """

        #cazul in care se aloca acelasi ip unei masini (static binding)
        staticIp = self.findIPByMac(_mac)
        if staticIp != None:
            staticIp.set_IP_unavailable()
            staticIp.keep_IP_address()
            return staticIp

        elif option50.values != None:
            requested = self.findIPObjByIPAddr(option50)




    def findIPObjByIPAddr(self, ip):
        return [ipobj for ipobj in self.adreseIP if ipobj.ip == ip].pop()


    def findIPByMac(self, _mac):
        return [ip for ip in self.adreseIP if ip.mac == _mac].pop()
# if __name__ == '__main__':
#     ap = AddressPool("192.168.1.0", "255.255.255.0")







